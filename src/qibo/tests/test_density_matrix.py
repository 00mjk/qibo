import numpy as np
import pytest
from qibo import gates, models, callbacks

_EINSUM_BACKENDS = ["DefaultEinsum", "MatmulEinsum"]
_atol = 1e-8


def random_density_matrix(nqubits: int) -> np.ndarray:
    """Generates a random density matrix.

    Note that the density matrix generated by this method is not necessarily
    positive. This is okay for most tests but may not work for some cases such
    as the entanglement entropy calculation.
    """
    shape = 2 * (2 ** nqubits,)
    rho = np.random.random(shape) + 1j * np.random.random(shape)
    # Make Hermitian
    rho = (rho + rho.T.conj()) / 2.0
    # Normalize
    ids = np.arange(2 ** nqubits)
    rho[ids, ids] = rho[ids, ids] / np.trace(rho)
    return rho


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_xgate_application_onequbit(einsum_choice):
    """Check applying one qubit gate to one qubit density matrix."""
    initial_rho = random_density_matrix(1)
    gate = gates.X(0).with_backend(einsum_choice)
    final_rho = gate(initial_rho, is_density_matrix=True).numpy()

    pauliX = np.array([[0, 1], [1, 0]])
    target_rho = pauliX.dot(initial_rho).dot(pauliX)

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_hgate_application_twoqubit(einsum_choice):
    """Check applying one qubit gate to two qubit density matrix."""
    initial_rho = random_density_matrix(2)
    gate = gates.H(1).with_backend(einsum_choice)
    final_rho = gate(initial_rho.reshape(4 * (2,)), is_density_matrix=True
                     ).numpy().reshape((4, 4))

    matrix = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
    matrix = np.kron(np.eye(2), matrix)
    target_rho = matrix.dot(initial_rho).dot(matrix)

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_rygate_application_twoqubit(einsum_choice):
    """Check applying non-hermitian one qubit gate to one qubit density matrix."""
    theta = 0.1234
    initial_rho = random_density_matrix(1)

    gate = gates.RY(0, theta=theta).with_backend(einsum_choice)
    gate.nqubits = 1
    final_rho = gate(initial_rho, is_density_matrix=True).numpy()

    phase = np.exp(1j * theta / 2.0)
    matrix = phase * np.array([[phase.real, -phase.imag], [phase.imag, phase.real]])
    target_rho = matrix.dot(initial_rho).dot(matrix.T.conj())

    np.testing.assert_allclose(final_rho, target_rho, atol=_atol)


@pytest.mark.parametrize("einsum_choice", ["MatmulEinsum"])
def test_czpowgate_application_twoqubit(einsum_choice):
    """Check applying two qubit gate to three qubit density matrix."""
    theta = 0.1234
    nqubits = 3
    initial_rho = random_density_matrix(nqubits)

    gate = gates.CZPow(0, 1, theta=theta).with_backend(einsum_choice)
    final_rho = gate(initial_rho.reshape(2 * nqubits * (2,)),
                     is_density_matrix=True).numpy().reshape(initial_rho.shape)

    matrix = np.eye(4, dtype=np.complex128)
    matrix[3, 3] = np.exp(1j * theta)
    matrix = np.kron(matrix, np.eye(2))
    target_rho = matrix.dot(initial_rho).dot(matrix.T.conj())

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_circuit_compiled(einsum_choice):
    """Check passing density matrix as initial state to a compiled circuit."""
    theta = 0.1234
    initial_rho = random_density_matrix(3)

    c = models.Circuit(3)
    c.add(gates.H(0).with_backend(einsum_choice))
    c.add(gates.H(1).with_backend(einsum_choice))
    c.add(gates.CNOT(0, 1).with_backend(einsum_choice))
    c.add(gates.H(2).with_backend(einsum_choice))
    final_rho = c(initial_rho).numpy().reshape(initial_rho.shape)

    h = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
    cnot = np.array([[1, 0, 0, 0], [0, 1, 0, 0],
                     [0, 0, 0, 1], [0, 0, 1, 0]])
    m1 = np.kron(np.kron(h, h), np.eye(2))
    m2 = np.kron(cnot, np.eye(2))
    m3 = np.kron(np.eye(4), h)
    target_rho = m1.dot(initial_rho).dot(m1.T.conj())
    target_rho = m2.dot(target_rho).dot(m2.T.conj())
    target_rho = m3.dot(target_rho).dot(m3.T.conj())

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_circuit(einsum_choice):
    """Check passing density matrix as initial state to circuit."""
    theta = 0.1234
    initial_rho = random_density_matrix(3)

    c = models.Circuit(3)
    c.add(gates.X(2).with_backend(einsum_choice))
    c.add(gates.CZPow(0, 1, theta=theta).with_backend(einsum_choice))
    final_rho = c(initial_rho).numpy().reshape(initial_rho.shape)

    m1 = np.kron(np.eye(4), np.array([[0, 1], [1, 0]]))
    m2 = np.eye(4, dtype=np.complex128)
    m2[3, 3] = np.exp(1j * theta)
    m2 = np.kron(m2, np.eye(2))
    target_rho = m1.dot(initial_rho).dot(m1)
    target_rho = m2.dot(target_rho).dot(m2.T.conj())

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_controlled_by_simple(einsum_choice):
    """Check controlled_by method on gate."""
    psi = np.zeros(4)
    psi[0] = 1
    initial_rho = np.outer(psi, psi.conj())

    c = models.Circuit(2)
    c.add(gates.X(0).with_backend(einsum_choice))
    c.add(gates.Y(1).with_backend(einsum_choice).controlled_by(0))
    final_rho = c(np.copy(initial_rho)).numpy()

    c = models.Circuit(2)
    c.add(gates.X(0).with_backend(einsum_choice))
    c.add(gates.Y(1).with_backend(einsum_choice))
    target_rho = c(np.copy(initial_rho)).numpy()

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_controlled_by_no_effect(einsum_choice):
    """Check controlled_by SWAP that should not be applied."""
    psi = np.zeros(2 ** 4)
    psi[0] = 1
    initial_rho = np.outer(psi, psi.conj())

    c = models.Circuit(4)
    c.add(gates.X(0).with_backend(einsum_choice))
    c.add(gates.SWAP(1, 3).with_backend(einsum_choice).controlled_by(0, 2))
    final_rho = c(np.copy(initial_rho)).numpy()

    c = models.Circuit(4)
    c.add(gates.X(0).with_backend(einsum_choice))
    target_rho = c(np.copy(initial_rho)).numpy()

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_controlled_with_effect(einsum_choice):
    """Check controlled_by SWAP that should be applied."""
    psi = np.zeros(2 ** 4)
    psi[0] = 1
    initial_rho = np.outer(psi, psi.conj())

    c = models.Circuit(4)
    c.add(gates.X(0).with_backend(einsum_choice))
    c.add(gates.X(2).with_backend(einsum_choice))
    c.add(gates.SWAP(1, 3).with_backend(einsum_choice).controlled_by(0, 2))
    final_rho = c(np.copy(initial_rho)).numpy()

    c = models.Circuit(4)
    c.add(gates.X(0).with_backend(einsum_choice))
    c.add(gates.X(2).with_backend(einsum_choice))
    c.add(gates.SWAP(1, 3).with_backend(einsum_choice))
    target_rho = c(np.copy(initial_rho)).numpy()

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_bitflip_noise(einsum_choice):
    """Test `gates.NoiseChannel` on random initial density matrix."""
    initial_rho = random_density_matrix(2)

    c = models.Circuit(2)
    c.add(gates.NoiseChannel(1, px=0.3).with_backend(einsum_choice))
    final_rho = c(np.copy(initial_rho)).numpy()

    c = models.Circuit(2)
    c.add(gates.X(1).with_backend(einsum_choice))
    target_rho = 0.3 * c(np.copy(initial_rho)).numpy()
    target_rho += 0.7 * initial_rho.reshape(target_rho.shape)

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_circuit_switch_to_density_matrix(einsum_choice):
    """Test that using `gates.NoiseChnanel` switches vector to density matrix."""
    c = models.Circuit(2)
    c.add(gates.H(0).with_backend(einsum_choice))
    c.add(gates.H(1).with_backend(einsum_choice))
    c.add(gates.NoiseChannel(0, px=0.5).with_backend(einsum_choice))
    c.add(gates.NoiseChannel(1, pz=0.3).with_backend(einsum_choice))
    final_rho = c().numpy()

    psi = np.ones(4) / 2
    initial_rho = np.outer(psi, psi.conj())
    c = models.Circuit(2)
    c.add(gates.NoiseChannel(0, px=0.5).with_backend(einsum_choice))
    c.add(gates.NoiseChannel(1, pz=0.3).with_backend(einsum_choice))
    target_rho = c(initial_rho).numpy()

    np.testing.assert_allclose(final_rho, target_rho)


@pytest.mark.parametrize("einsum_choice", _EINSUM_BACKENDS)
def test_general_channel(einsum_choice):
    """Test `gates.GeneralChannel`."""
    psi = np.random.random(4) + 1j * np.random.random(4)
    psi = psi / np.sqrt((np.abs(psi) ** 2).sum())

    c = models.Circuit(2)
    a1 = np.sqrt(0.4) * np.array([[0, 1], [1, 0]])
    a2 = np.sqrt(0.6) * np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
    gate = gates.GeneralChannel([((1,), a1), ((0, 1), a2)])
    assert gate.target_qubits == (0, 1)
    c.add(gate.with_backend(einsum_choice))
    final_rho = c(psi).numpy()

    initial_rho = np.outer(psi, psi.conj())
    m1 = np.kron(np.eye(2), a1)
    m2 = a2
    target_rho = (m1.dot(initial_rho).dot(m1.conj().T) +
                  m2.dot(initial_rho).dot(m2.conj().T))

    np.testing.assert_allclose(final_rho, target_rho)


def test_entanglement_entropy():
    """Check that entanglement entropy calculation works for density matrices."""
    rho = random_density_matrix(4)
    # this rho is not always positive. Make rho positive for this application
    _, u = np.linalg.eigh(rho)
    rho = u.dot(np.diag(5 * np.random.random(u.shape[0]))).dot(u.conj().T)
    # this is a positive rho

    entropy = callbacks.EntanglementEntropy([0, 2])
    final_ent = entropy(rho, is_density_matrix=True)

    rho = rho.reshape(8 * (2,))
    reduced_rho = np.einsum("abcdafch->bdfh", rho).reshape((4, 4))
    eigvals = np.linalg.eigvalsh(reduced_rho).real
    # assert that all eigenvalues are non-negative
    assert (eigvals >= 0).prod()
    mask = eigvals > 0
    target_ent = - (eigvals[mask] * np.log2(eigvals[mask])).sum()

    np.testing.assert_allclose(final_ent, target_ent)
